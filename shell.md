## shell环境
Shell只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。Linux 的 Shell 种类众多，常见的有： <br>
1.Bourne Shell（/usr/bin/sh或/bin/sh）:是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。 <br>
2.Bourne Again Shell（/bin/bash): LinuxOS 默认的，它是 Bourne Shell 的扩展。与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 <br>
3.C Shell（/usr/bin/csh）:是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。 <br>
4.K Shell（/usr/bin/ksh）:集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。 <br>
在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again。，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。#! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。
## 运行 Shell 脚本有两种方法：
1.作为可执行程序
保存为 ***.sh，并 cd 到相应目录

```
chmod +x ./test.sh  #使脚本具有执行权限
./test.sh  #执行脚本
```
注意，要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，自己的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 <br>
2.作为解释器参数
这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：

```
/bin/sh test.sh
```
这种方式运行的脚本，不需要在第一行指定解释器信息。
## shell变量
### 1.定义变量
定义变量时，变量名不加美元符号

```
name="jjjj"
```
1.命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 <br>
2.中间不能有空格，可以使用下划线（_） <br>
3.不能使用标点符号。 <br>
4.不能使用bash里的关键字（可用help命令查看保留关键字). <br>
### 2.使用变量
使用一个定义过的变量，只要在变量名前面加美元符号即可。已定义的变量，也可以被重新定义。

```
name="jjjj"
echo $name
 #花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界
 echo ${name}
```
### 3.只读变量
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

```
语法：readonly variable_name
```
### 4.删除变量
使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。

```
语法：unset variable_name
```
### 5.变量类型
运行shell时，会同时存在三种变量： <br>
1. 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 <br>
2.环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 <br>
3.shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。 <br>
## shell字符串
### 1.单双引号
字符串可以用单引号，也可以用双引号，也可以不用引号。 <br>
两者区别： <br>
1.单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的，而双引号里可以有变量。 <br>
2.单引号字串中不能出现单引号（对单引号使用转义符后也不行），双引号里可以出现转义字符。 <br>
### 2.字符串的一些操作
假设定义有变量str=http://www.qqq.com/123.htm

1. #号截取，删除左边字符，保留右边字符。


```
echo ${str#*//}
```

 #号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符。
 结果为：www.qqq.com/123.htm <br>
 
 2.## 号截取，删除左边字符，保留右边字符。
 
```
echo ${var##*/}
```
   ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符，结果是：123.htm <br>
3. %号截取，删除右边字符，保留左边字符

```
echo ${var%/*}
```
%/* 表示从右边开始，删除第一个 / 号及右边的字符，结果是：http://www.qqq.com <br>
4.%% 号截取，删除右边字符，保留左边字符

```
echo ${var%%/*}
```
%%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符，结果是：http: <br>
5.从左边第几个字符开始，及字符的个数

```
echo ${var:0:5}
```
其中的 0 表示左边第一个字符开始，5 表示字符的总个数。结果是:http: <br>
6.从左边第几个字符开始，一直到结束。

```
echo ${var:7}
```
其中的 7 表示左边第8个字符开始，一直到结束。结果是：www.qqq.com/123.htm <br>
7.从右边第几个字符开始，及字符的个数

```
echo ${var:0-7:3}
```
其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。结果为:
123 <br>
8. 从右边第几个字符开始，一直到结束。
```
echo ${var:0-7}
```
表示从右边第七个字符开始，一直到结束。结果是：123.htm
## shell数组
bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由0开始编号。 <br>
数组的定义： <br>
在Shell中，用括号来表示数组，数组元素用"空格"符号分割开。

```
数组名=(值1 值2 ... 值n)
```
### 取得数组元素的个数
length=${#array_name[@]}
### 取得数组单个元素的长度
length=${#array_name[n]}
### 数组的遍历：

```

num=("a" "b" "c" "d")

FOR循环遍历输出数组

for i in ${num[@]}
do
  echo $i
done


WHILE循环输出

i=0
while [ $i -lt ${#num[@]} ]
do
  echo ${num[$i]}
  let i++
done
```

## shell传递参数：


| 参数处理 | 说明 |
| :-- | :-- |
| $# | 传递到脚本的参数个数 |
| $0 | 脚本名字 |
| $1 | 传递到脚本的第一个参数 |
| $* | 以一个单字符串显示所有向脚本传递的参数。 |
| $$ | 脚本运行的当前进程ID号 |
| $! | 后台运行的最后一个进程的ID号 |
| $@ | 与$*相同，但是使用时加引号，并在引号中返回每个参数。 |
| $- | 显示Shell使用的当前选项 |
| $? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

$*和$@的区别： <br>
相同点：都是引用所有参数。 <br>
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

## shell运算符

### 1.算数运算符
+，-，*，/, %，=，==， !=
### 2.逻辑运算符
&&， ||

注意：在写条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]
### 3.关系运算符
| 运算符 | 说明 |
| --- | --- |
| -eq | 检测两个数是否相等，相等返回 true。 |
| -ne | 检测两个数是否相等，不相等返回 true。 |
| -gt | 检测左边的数是否大于右边的，如果是，则返回 true。 |
| -lt | 检测左边的数是否小于右边的，如果是，则返回 true。 |
| -ge | 检测左边的数是否大于等于右边的，如果是，则返回 true。 |
| -le | 检测左边的数是否小于等于右边的，如果是，则返回 true。 |

### 4.布尔运算符

| 运算符 | 说明 |
| --- | --- |
| ！ | 非运算 |
| -o | 或运算，有一个表达式为 true 则返回 true。 |
| -a | 与运算，两个表达式都为 true 才返回 true。 |

### 5.字符串运算符


| 运算符 | 说明 |
| --- | --- |
| = | 检测两个字符串是否相等，相等返回 true。  |
| != | 检测两个字符串是否相等，不相等返回 true。  |
| -z | 检测字符串长度是否为0，为0返回 true  |
| -n | 检测字符串长度是否为0，不为0返回 true。 |
| Str | 检测字符串是否为空，不为空返回 true。<span class="Apple-tab-span" style="white-space:pre"></span> |

### 6.文件测试运算符

| 操作符 | 说明 |
| --- | --- |
| -b | 检测文件是否是块设备文件，如果是，则返回 true。 |
| -c | 检测文件是否是字符设备文件，如果是，则返回 true。 |
| -d | 检测文件是否是目录，如果是，则返回 true。 |
| -f | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 |
| -g | 检测文件是否设置了 SGID 位，如果是，则返回 true。 |
| -k | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。<span class="Apple-tab-span" style="white-space:pre"></span> |
| -p | 检测文件是否是有名管道，如果是，则返回 true。 |
| -u | 检测文件是否设置了 SUID 位，如果是，则返回 true。 |
| -r | 检测文件是否可读，如果是，则返回 true。 |
| -w | 检测文件是否可写，如果是，则返回 true。 |
| -x | 检测文件是否可执行，如果是，则返回 true。 |
| -s | 检测文件是否为空（文件大小是否大于0），不为空返回 true。  |
| -e | 检测文件（包括目录）是否存在，如果是，则返回 true。 |

## shell test命令

Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。


| 数值测试 | 说明 |
| --- | --- |
| -eq | 等于则为真 |
| -ne | 不等于则为真 |
| -gt | 大于则为真 |
| -ge | 大于等于则为真 |
| -lt | 小于则为真 |
| -le | 小于等于则为真 |


```
num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
```
## shell流程控制
### 1.if循环

```
if condition
then
    command1 
    ...
elif
then
    ....
else
    ...
fi
```
### 2.for循环

```
for var in item1 item2 ... itemN
do
    command1
    command2
    ...
done
```
in列表是可选的，如果不用它，for循环使用命令行的位置参数。

### 3.while循环

```
while condition #condition为true或:表示无限循环
do
    command
done
```
### 4.until循环
until循环执行一系列命令直至条件为真时停止。

```
until condition
do
    command
done
```
### 5.case语句

```
case 值 in
模式1)
    command1
    command2
    ...
    commandN
;;
模式2）
    command1
    command2
    ...
    commandN
;;
*)
    command1
    command2
    ...
    commandN
;;
```
## shell函数

```
function test(){
    
}

test #函数执行
```
参数返回，可以显示加return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)。

## shell的输入/输出重定向

| 命令<span class="Apple-tab-span" style="white-space:pre"></span>  | 说明 |
| --- | --- |
| command > file | 将输出重定向到 file |
| command < file | 将输入重定向到 file |
| command >> file | 将输出以追加的方式重定向到 file |
| n > file | 将文件描述符为 n 的文件重定向到 file |
| n >> file | 将文件描述符为 n 的文件以追加的方式重定向到 file |
| n >& m | 将输出文件 m 和 n 合并 |
| n <& m | 将输入文件 m 和 n 合并 |
| << tag | 将开始标记 tag 和结束标记 tag 之间的内容作为输入 |

例如：
如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：
command > file 2>&1  &表示重定向的目标不是一个文件，而是一个文件描述符
或者
command >> file 2>&1

如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：
command > /dev/null

## shell的文件包含
Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。

```
. filename
或者
source filename
```

## shell读取文件
每次读取文件的一行，逐行读取并进行相应处理。
第一种：

```
#!/bin/bash

while read line
do
    echo $line
done < file(待读取的文件)
```
这种效率是最高的。
第二种:

```
#!/bin/bash

cat file(待读取的文件) | while read line
do
    echo $line
done
```
注意:这种文件读取方式，需要注意当你在其中对一些变量进行修改时，会无效。
第三种：

```
for line in `cat file(待读取的文件)`
do
    echo $line
done
```
## shell的字体颜色设置
在Shell下有时候需要定制输出，比如给输出加上颜色，或者显示高亮，或者添加闪烁等。可以把颜色设置的这些函数写入到一个公共的SHELL脚本中，每次在编写其他脚本的时候进行调用。

格式：

```
echo -e "\033[字背景颜色;字体颜色m字符串\033[控制码"
```

一些控制码:

| 控制码 | 说明 |
| --- | --- |
| \33[0m |  关闭所有属性 |
| \33[01m | 设置高亮度  |
| \33[04m | 下划线  |
| \33[05m | 闪烁 |
| \33[07m |  反显  |
| \33[08m | 消隐  |
| \33[30m -- \33[37m | 设置前景色 |
| \33[40m -- \33[47m | 设置背景色 |
| \33[nA | 光标上移n行 |
| \33[nB | 光标下移n行 |
| \33[nC | 光标右移n行 |
| \33[nD | 光标左移n行 |
| \33[y;xH | 设置光标位置 |
| \33[2J | 清屏 |
| \33[K | 清除从光标到行尾的内容 |
| \33[s | 保存光标位置  |
| \33[u | 恢复光标位置 |
| \33[?25l | 隐藏光标 |
| \33[?25h | 显示光标 |

## shell中的一些进程管理命令

| 命令 | 说明 |
| --- | --- |
| wait | 等待作业号或者进程号制定的进程退出，返回最后一个作业或进程的退出状态状态。如果没有制定参数，则等待所有子进程的退出，其退出状态为0. |
| kill | 发送信号给一个或多个进程 |
| jobs | 查看当前有多少在后台运行的命令 |
| bg | 将一个在后台暂停的命令，变成继续执行 |
| fg | 将后台中的命令调至前台继续运行 |
| ps | 列出系统中正在运行的进程 |

## tput命令
tput命令可以通过 terminfo 数据库对终端会话进行一些操作

| 参数 | 说明 |
| --- | --- |
| tput clear | 清屏 |
| tput sc | 保存当前光标位置 |
| tput cup x y | 将光标移动到 row col |
| tput civis | 光标不可见 |
| tput cnorm | 光标可见 |
| tput rc | 显示输出 |



